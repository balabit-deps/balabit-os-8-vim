[Ubuntu note: ops.c code was moved from register.c
changed ml_get_len() to STRLEN(ml_get())
--Hlib Korzhynskyy]

Backport of:

From c9a1e257f1630a0866447e53a564f7ff96a80ead Mon Sep 17 00:00:00 2001
From: Christian Brabandt <cb@256bit.org>
Date: Sat, 11 Jan 2025 15:25:00 +0100
Subject: [PATCH] patch 9.1.1003: [security]: heap-buffer-overflow with visual
 mode

Problem:  [security]: heap-buffer-overflow with visual mode when
          using :all, causing Vim trying to access beyond end-of-line
          (gandalf)
Solution: Reset visual mode on :all, validate position in gchar_pos()
          and charwise_block_prep()

This fixes CVE-2025-22134

Github Advisory:
https://github.com/vim/vim/security/advisories/GHSA-5rgf-26wj-48v8

Co-authored-by: zeertzjq <zeertzjq@outlook.com>
Signed-off-by: Christian Brabandt <cb@256bit.org>
---
 src/arglist.c               |  4 ++++
 src/misc1.c                 |  4 ++++
 src/ops.c                   |  3 ++-
 src/testdir/test_visual.vim | 26 ++++++++++++++++++++++----
 src/version.c               |  2 ++
 5 files changed, 34 insertions(+), 5 deletions(-)

Index: vim-8.1.2269/src/arglist.c
===================================================================
--- vim-8.1.2269.orig/src/arglist.c
+++ vim-8.1.2269/src/arglist.c
@@ -915,6 +915,10 @@ do_arg_all(
     need_mouse_correct = TRUE;
 # endif
 
+    // Stop Visual mode, the cursor and "VIsual" may very well be invalid after
+    // switching to another buffer.
+    reset_VIsual_and_resel();
+
     // Try closing all windows that are not in the argument list.
     // Also close windows that are not full width;
     // When 'hidden' or "forceit" set the buffer becomes hidden.
Index: vim-8.1.2269/src/misc1.c
===================================================================
--- vim-8.1.2269.orig/src/misc1.c
+++ vim-8.1.2269/src/misc1.c
@@ -510,11 +510,15 @@ plines_m_win(win_T *wp, linenr_T first,
 gchar_pos(pos_T *pos)
 {
     char_u	*ptr;
+    int		ptrlen;
 
     /* When searching columns is sometimes put at the end of a line. */
     if (pos->col == MAXCOL)
 	return NUL;
+    ptrlen = STRLEN(ml_get(pos->lnum));
     ptr = ml_get_pos(pos);
+    if (pos->col > ptrlen)
+	return NUL;
     if (has_mbyte)
 	return (*mb_ptr2char)(ptr);
     return (int)*ptr;
Index: vim-8.1.2269/src/testdir/test_visual.vim
===================================================================
--- vim-8.1.2269.orig/src/testdir/test_visual.vim
+++ vim-8.1.2269/src/testdir/test_visual.vim
@@ -518,6 +518,24 @@ func Test_visual_block_put_invalid()
   behave xterm
 endfunc
 
+" the following caused a Heap-Overflow, because Vim was accessing outside of a
+" line end
+func Test_visual_pos_buffer_heap_overflow()
+  set virtualedit=all
+  args Xa Xb
+  all
+  call setline(1, ['', '', ''])
+  call cursor(3, 1)
+  wincmd w
+  call setline(1, 'foobar')
+  normal! $lv0
+  all
+  call setreg('"', 'baz')
+  normal! [P
+  set virtualedit=
+  bw! Xa Xb
+endfunc
+
 
 " Check fix for the heap-based buffer overflow bug found in the function
 " utfc_ptr2len and reported at
Index: vim-8.1.2269/src/register.c
===================================================================
--- vim-8.1.2269.orig/src/register.c
+++ vim-8.1.2269/src/register.c
@@ -1171,6 +1171,7 @@ op_yank(oparg_T *oap, int deleting, int
 		    colnr_T startcol = 0, endcol = MAXCOL;
 		    int is_oneChar = FALSE;
 		    colnr_T cs, ce;
+		    int	plen = STRLEN(ml_get(lnum));
 
 		    p = ml_get(lnum);
 		    bd.startspaces = 0;
@@ -1231,7 +1232,7 @@ op_yank(oparg_T *oap, int deleting, int
 			bd.textlen = 0;
 		    else
 			bd.textlen = endcol - startcol + oap->inclusive;
-		    bd.textstart = p + startcol;
+		    bd.textstart = startcol <= plen ? p + startcol : p;
 		    if (yank_copy_line(&bd, y_idx) == FAIL)
 			goto fail;
 		    break;
