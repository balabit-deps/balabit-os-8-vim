From 0a6e57b09bc8c76691b367a5babfb79b31b770e8 Mon Sep 17 00:00:00 2001
From: Christian Brabandt <cb@256bit.org>
Date: Thu, 15 Aug 2024 22:15:28 +0200
Subject: [PATCH] patch 9.1.0678: [security]: use-after-free in alist_add()

Problem:  [security]: use-after-free in alist_add()
          (SuyueGuo)
Solution: Lock the current window, so that the reference to
          the argument list remains valid.

This fixes CVE-2024-43374

Signed-off-by: Christian Brabandt <cb@256bit.org>
---
 src/arglist.c                |  6 ++++++
 src/buffer.c                 |  4 ++--
 src/ex_cmds.c                |  4 ++--
 src/proto/window.pro         |  1 +
 src/structs.h                |  2 +-
 src/terminal.c               |  4 ++--
 src/testdir/test_arglist.vim | 23 +++++++++++++++++++++++
 src/version.c                |  2 ++
 src/window.c                 | 29 +++++++++++++++++++----------
 9 files changed, 58 insertions(+), 17 deletions(-)

Index: vim-8.1.2269/src/arglist.c
===================================================================
--- vim-8.1.2269.orig/src/arglist.c
+++ vim-8.1.2269/src/arglist.c
@@ -174,6 +174,8 @@ alist_set(
 /*
  * Add file "fname" to argument list "al".
  * "fname" must have been allocated and "al" must have been checked for room.
+ *
+ * May trigger Buf* autocommands
  */
     void
 alist_add(
@@ -183,6 +185,8 @@ alist_add(
 {
     if (fname == NULL)		// don't add NULL file names
 	return;
+
+    curwin->w_locked = TRUE;
 #ifdef BACKSLASH_IN_FILENAME
     slash_adjust(fname);
 #endif
@@ -191,6 +195,8 @@ alist_add(
 	AARGLIST(al)[al->al_ga.ga_len].ae_fnum =
 	    buflist_add(fname, BLN_LISTED | (set_fnum == 2 ? BLN_CURBUF : 0));
     ++al->al_ga.ga_len;
+
+    curwin->w_locked = FALSE;
 }
 
 #if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)
@@ -347,6 +353,7 @@ alist_add_list(
 	if (after < ARGCOUNT)
 	    mch_memmove(&(ARGLIST[after + count]), &(ARGLIST[after]),
 				       (ARGCOUNT - after) * sizeof(aentry_T));
+	curwin->w_locked = TRUE;
 	for (i = 0; i < count; ++i)
 	{
 	    int flags = BLN_LISTED | (will_edit ? BLN_CURBUF : 0);
@@ -354,6 +361,7 @@ alist_add_list(
 	    ARGLIST[after + i].ae_fname = files[i];
 	    ARGLIST[after + i].ae_fnum = buflist_add(files[i], flags);
 	}
+	curwin->w_locked = FALSE;
 	ALIST(curwin)->al_ga.ga_len += count;
 	if (old_argcount > 0 && curwin->w_arg_idx >= after)
 	    curwin->w_arg_idx += count;
Index: vim-8.1.2269/src/buffer.c
===================================================================
--- vim-8.1.2269.orig/src/buffer.c
+++ vim-8.1.2269/src/buffer.c
@@ -1471,7 +1471,7 @@ do_buffer(
 	 * a window with this buffer.
 	 */
 	while (buf == curbuf
-		   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)
+		   && !(win_locked(curwin) || curwin->w_buffer->b_locked > 0)
 		   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))
 	{
 	    if (win_close(curwin, FALSE) == FAIL)
@@ -5072,7 +5072,7 @@ ex_buffer_all(exarg_T *eap)
 							    - tabline_height()
 			: wp->w_width != Columns)
 		    || (had_tab > 0 && wp != firstwin)) && !ONE_WINDOW
-			     && !(wp->w_closing || wp->w_buffer->b_locked > 0))
+			     && !(win_locked(wp) || wp->w_buffer->b_locked > 0))
 	    {
 		win_close(wp, FALSE);
 		wpnext = firstwin;	/* just in case an autocommand does
Index: vim-8.1.2269/src/ex_cmds.c
===================================================================
--- vim-8.1.2269.orig/src/ex_cmds.c
+++ vim-8.1.2269/src/ex_cmds.c
@@ -2708,7 +2708,7 @@ do_ecmd(
 
 		/* Set the w_closing flag to avoid that autocommands close the
 		 * window.  And set b_locked for the same reason. */
-		the_curwin->w_closing = TRUE;
+		the_curwin->w_locked = TRUE;
 		++buf->b_locked;
 
 		if (curbuf == old_curbuf.br_buf)
@@ -2720,7 +2720,7 @@ do_ecmd(
 		close_buffer(oldwin, curbuf,
 			       (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE);
 
-		the_curwin->w_closing = FALSE;
+		the_curwin->w_locked = FALSE;
 		--buf->b_locked;
 
 #ifdef FEAT_EVAL
Index: vim-8.1.2269/src/proto/window.pro
===================================================================
--- vim-8.1.2269.orig/src/proto/window.pro
+++ vim-8.1.2269/src/proto/window.pro
@@ -77,4 +77,5 @@ int win_hasvertsplit(void);
 int get_win_number(win_T *wp, win_T *first_win);
 int get_tab_number(tabpage_T *tp);
 char *check_colorcolumn(win_T *wp);
+int win_locked(win_T *wp);
 /* vim: set ft=c : */
Index: vim-8.1.2269/src/structs.h
===================================================================
--- vim-8.1.2269.orig/src/structs.h
+++ vim-8.1.2269/src/structs.h
@@ -2944,7 +2944,7 @@ struct window_S
     synblock_T	*w_s;		    // for :ownsyntax
 #endif
 
-    int		w_closing;	    // window is being closed, don't let
+    int		w_locked;	    // window is being closed, don't let
 				    // autocommands close it too.
 
     frame_T	*w_frame;	    // frame containing this window
Index: vim-8.1.2269/src/terminal.c
===================================================================
--- vim-8.1.2269.orig/src/terminal.c
+++ vim-8.1.2269/src/terminal.c
@@ -3154,10 +3154,10 @@ term_after_channel_closed(term_T *term)
 	    if (curwin == aucmd_win)
 		do_set_w_closing = TRUE;
 	    if (do_set_w_closing)
-		curwin->w_closing = TRUE;
+		curwin->w_locked = TRUE;
 	    do_bufdel(DOBUF_WIPE, (char_u *)"", 1, fnum, fnum, FALSE);
 	    if (do_set_w_closing)
-		curwin->w_closing = FALSE;
+		curwin->w_locked = FALSE;
 	    aucmd_restbuf(&aco);
 	    return TRUE;
 	}
Index: vim-8.1.2269/src/version.c
===================================================================
--- vim-8.1.2269.orig/src/version.c
+++ vim-8.1.2269/src/version.c
@@ -4032,6 +4032,8 @@ static int included_patches[] =
 /**/
     648,
 /**/
+    678,
+/**/
     647,
 /**/
     646,
Index: vim-8.1.2269/src/window.c
===================================================================
--- vim-8.1.2269.orig/src/window.c
+++ vim-8.1.2269/src/window.c
@@ -2277,7 +2277,7 @@ close_windows(
     for (wp = firstwin; wp != NULL && !ONE_WINDOW; )
     {
 	if (wp->w_buffer == buf && (!keep_curwin || wp != curwin)
-		&& !(wp->w_closing || wp->w_buffer->b_locked > 0))
+		&& !(win_locked(wp) || wp->w_buffer->b_locked > 0))
 	{
 	    if (win_close(wp, FALSE) == FAIL)
 		/* If closing the window fails give up, to avoid looping
@@ -2298,7 +2298,7 @@ close_windows(
 	if (tp != curtab)
 	    for (wp = tp->tp_firstwin; wp != NULL; wp = wp->w_next)
 		if (wp->w_buffer == buf
-		    && !(wp->w_closing || wp->w_buffer->b_locked > 0))
+		    && !(win_locked(wp) || wp->w_buffer->b_locked > 0))
 		{
 		    win_close_othertab(wp, FALSE, tp);
 
@@ -2429,10 +2429,10 @@ win_close_buffer(win_T *win, int action,
 	bufref_T    bufref;
 
 	set_bufref(&bufref, curbuf);
-	win->w_closing = TRUE;
+	win->w_locked = TRUE;
 	close_buffer(win, win->w_buffer, action, abort_if_last);
 	if (win_valid_any_tab(win))
-	    win->w_closing = FALSE;
+	    win->w_locked = FALSE;
 	// Make sure curbuf is valid. It can become invalid if 'bufhidden' is
 	// "wipe".
 	if (!bufref_valid(&bufref))
@@ -2467,7 +2467,7 @@ win_close(win_T *win, int free_buf)
 	return FAIL;
     }
 
-    if (win->w_closing || (win->w_buffer != NULL
+    if (win_locked(win) || (win->w_buffer != NULL
 					       && win->w_buffer->b_locked > 0))
 	return FAIL; /* window is already being closed */
     if (win_unlisted(win))
@@ -2516,19 +2516,19 @@ win_close(win_T *win, int free_buf)
 	    other_buffer = TRUE;
 	    if (!win_valid(win))
 		return FAIL;
-	    win->w_closing = TRUE;
+	    win->w_locked = TRUE;
 	    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);
 	    if (!win_valid(win))
 		return FAIL;
-	    win->w_closing = FALSE;
+	    win->w_locked = FALSE;
 	    if (last_window())
 		return FAIL;
 	}
-	win->w_closing = TRUE;
+	win->w_locked = TRUE;
 	apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);
 	if (!win_valid(win))
 	    return FAIL;
-	win->w_closing = FALSE;
+	win->w_locked = FALSE;
 	if (last_window())
 	    return FAIL;
 #ifdef FEAT_EVAL
@@ -2675,7 +2675,7 @@ win_close_othertab(win_T *win, int free_
 
     /* Get here with win->w_buffer == NULL when win_close() detects the tab
      * page changed. */
-    if (win->w_closing || (win->w_buffer != NULL
+    if (win_locked(win) || (win->w_buffer != NULL
 					       && win->w_buffer->b_locked > 0))
 	return; /* window is already being closed */
 
@@ -6787,3 +6787,12 @@ skip:
     return NULL;  // no error
 }
 #endif
+
+/*
+ * Don't let autocommands close the given window
+ */
+   int
+win_locked(win_T *wp)
+{
+    return wp->w_locked;
+}
Index: vim-8.1.2269/src/testdir/test_arglist.vim
===================================================================
--- vim-8.1.2269.orig/src/testdir/test_arglist.vim
+++ vim-8.1.2269/src/testdir/test_arglist.vim
@@ -350,6 +350,7 @@ func Test_argv()
   call assert_equal('', argv(1, 100))
   call assert_equal([], argv(-1, 100))
   call assert_equal('', argv(10, -1))
+  %argdelete
 endfunc
 
 " Test for the :argedit command
Index: vim-8.1.2269/src/testdir/test_window_cmd.vim
===================================================================
--- vim-8.1.2269.orig/src/testdir/test_window_cmd.vim
+++ vim-8.1.2269/src/testdir/test_window_cmd.vim
@@ -553,7 +553,7 @@ func Test_access_freed_mem()
   au * 0 vs xxx
   arg 0
   argadd
-  call assert_fails("all", "E249:")
+  call assert_fails("all", "E242:")
   au!
   bwipe xxx
   call assert_equal(&columns, winwidth(0))
