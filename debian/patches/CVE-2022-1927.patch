From 4d97a565ae8be0d4debba04ebd2ac3e75a0c8010 Mon Sep 17 00:00:00 2001
From: Bram Moolenaar <Bram@vim.org>
Date: Sat, 28 May 2022 14:25:35 +0100
Subject: [PATCH] patch 8.2.5037: cursor position may be invalid after "0;"
 range

Problem:    Cursor position may be invalid after "0;" range.
Solution:   Check the cursor position when it was set by ";" in the range.
---
 src/ex_docmd.c             | 24 +++++++++++++++++-------
 src/testdir/test_excmd.vim |  8 ++++++++
 src/version.c              |  2 ++
 3 files changed, 27 insertions(+), 7 deletions(-)

--- vim-8.1.2269.orig/src/ex_docmd.c
+++ vim-8.1.2269/src/ex_docmd.c
@@ -2873,6 +2873,8 @@ parse_cmd_address(exarg_T *eap, char **e
 {
     int		address_count = 1;
     linenr_T	lnum;
+    int		need_check_cursor = FALSE;
+    int		ret = FAIL;
 
     // Repeat for all ',' or ';' separated addresses.
     for (;;)
@@ -2922,7 +2924,7 @@ parse_cmd_address(exarg_T *eap, char **e
 	lnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,
 					eap->addr_count == 0, address_count++);
 	if (eap->cmd == NULL)	// error detected
-	    return FAIL;
+	    goto theend;
 	if (lnum == MAXLNUM)
 	{
 	    if (*eap->cmd == '%')   // '%' - all lines
@@ -2967,14 +2969,14 @@ parse_cmd_address(exarg_T *eap, char **e
 			    // there is no Vim command which uses '%' and
 			    // ADDR_WINDOWS or ADDR_TABS
 			    *errormsg = _(e_invrange);
-			    return FAIL;
+			    goto theend;
 			}
 			break;
 		    case ADDR_TABS_RELATIVE:
 		    case ADDR_UNSIGNED:
 		    case ADDR_QUICKFIX:
 			*errormsg = _(e_invrange);
-			return FAIL;
+			goto theend;
 		    case ADDR_ARGUMENTS:
 			if (ARGCOUNT == 0)
 			    eap->line1 = eap->line2 = 0;
@@ -3006,7 +3008,7 @@ parse_cmd_address(exarg_T *eap, char **e
 		if (eap->addr_type != ADDR_LINES)
 		{
 		    *errormsg = _(e_invrange);
-		    return FAIL;
+		    goto theend;
 		}
 
 		++eap->cmd;
@@ -3014,11 +3016,11 @@ parse_cmd_address(exarg_T *eap, char **e
 		{
 		    fp = getmark('<', FALSE);
 		    if (check_mark(fp) == FAIL)
-			return FAIL;
+			goto theend;
 		    eap->line1 = fp->lnum;
 		    fp = getmark('>', FALSE);
 		    if (check_mark(fp) == FAIL)
-			return FAIL;
+			goto theend;
 		    eap->line2 = fp->lnum;
 		    ++eap->addr_count;
 		}
@@ -3035,6 +3037,7 @@ parse_cmd_address(exarg_T *eap, char **e
 		curwin->w_cursor.lnum = eap->line2;
 		// don't leave the cursor on an illegal line or column
 		check_cursor();
+                need_check_cursor = TRUE;
 	    }
 	}
 	else if (*eap->cmd != ',')
@@ -3050,7 +3053,12 @@ parse_cmd_address(exarg_T *eap, char **e
 	if (lnum == MAXLNUM)
 	    eap->addr_count = 0;
     }
-    return OK;
+    ret = OK;
+
+theend:
+    if (need_check_cursor)
+	check_cursor();
+    return ret;
 }
 
 /*
--- vim-8.1.2269.orig/src/testdir/test_excmd.vim
+++ vim-8.1.2269/src/testdir/test_excmd.vim
@@ -44,3 +44,11 @@ func Test_buffers_lastused()
   bwipeout bufb
   bwipeout bufc
 endfunc
+
+" This was leaving the cursor in line zero
+func Test_using_zero_in_range()
+  new
+  norm o00
+  silent!  0;s/\%')
+  bwipe!
+endfunc
